%!TEX root=../main.tex

\section{Linearizability for the Priority Queue Data Structure}

We define the signature of a priority queue object to be the following:
\begin{enumerate*}
    \item $\minsert(x) \Rightarrow \allowbreak \true$ inserts $x$ into the priority queue
    \item $\peek() \Rightarrow x$ retrieves the current highest priority value in the priority queue that is currently $x$
    \item $\poll() \Rightarrow x$ removes the current highest priority value from the priority queue that is currently $x$.
\end{enumerate*}
The priority queue is initialized to be empty. We define the ML problem on a priority queue to be the following:

\begin{problem*}[Monitoring Linearizability for Priority Queue (MLPQ)]
   Given a priority queue history $H$, is $H$ linearizable?
\end{problem*}

Similar to stack and queue, we observe that the relative priority of any pair of elements within a priority queue also stays consistent throughout their lifetimes in the data type. Unlike stack and queue, this relation is not decided by the any linearizations but instead pre-determined by the values. In essence, we are given the total order on values $<$, where $a < b$ denotes value $b$ having higher priority than $a$. The value $a$ must not be accessed via $\peek$ or $\poll$ operations in the presence of a higher priority value $b$ in the priority queue. We can use this definitive behaviour of the consistent relative priority of elements within the data type to derive the algorithm.

Given a priority queue history $H$, let $l$ be some linearization such that $l$ is legal on $H_v$ for $v \in \vals_H$. We define $<_l$ as a binary relation on values such that $v_1 <_l v_2$ if there is an operation in $o \in H_{v_2}$, $\methodOf{o}\in\set{\peek, \poll}$ and $l(o_{\minsert(v_1)}) < l(o) < l(o_{\poll(v_1)})$.

\begin{proposition}\label{pq-partial-def}
    $l$ is legal iff $<_l \subseteq <$.
\end{proposition}

Intuitively, $v_1 <_l v_2$ declares $v_1$ to be of lower priority than $v_2$ in the linearization $l$. This order must be consistent with the given total order $<$ on values. We can also see that Proposition \ref{reduce-one-value} follows naturally from Proposition \ref{pq-partial-def}. Consequently, there must exists a lowest priority value in terms of the partial order $<_l$ given by any legal linearization $l$.

\begin{corollary}[Lowest Priority Value]
    Let $H$ be a linearizable priority queue history with distinct values with linearization $l$. Let the lowest priority value be $v = \min\set{\valOf{o} \;|\; o\in H}$ such that $H_v = \set{o_{\minsert(v)}, o_{\poll(v)}, o_{\peek_1(v)}, \allowbreak o_{\peek_2(v)}, ..., o_{\peek_k(v)}}$, $l(\minsert(v)) < l(\peek_1(v)) < l(\peek_2(v)) < ... < l(\peek_k(v)) < l(\poll(v))$. Then, for all other values $v' > v$, one of the following holds:
    \begin{enumerate}
        \item for all $o' \in H_{v'}$, $l(o') < l(o_{\peek_1(v)})$
        \item for all $o' \in H_{v'}$, $l(o_{\peek_i(v)}) < l(o') < l(o_{\peek_{i+1}(v)})$ for some $1 \leq i < k$
        \item for all $o' \in H_{v'}$, $l(o_{\peek_k(v)}) < l(o') < l(o_{\poll(v)})$
        \item for all $o' \in H_{v'}$, $l(o_{\poll(v)}) < l(o')$
    \end{enumerate}
\end{corollary}

\begin{corollary}\label{pqueue-low-cor}
    Let $H$ be a linearizable priority queue history with distinct values with linearization $l$. Let the lowest priority value be $v = \min\set{\valOf{o} \;|\; o\in H}$. Then, for all other values $v' > v$ and $o \in H_v \setminus \set{o_{\minsert(v)}}$, one of the following holds:
    \begin{enumerate}
        \item for all $o' \in H_{v'}$, $\invTimeOf{o'} < l(o)$, or
        \item for all $o' \in H_{v'}$, $l(o) < \resTimeOf{o'}$
    \end{enumerate}
\end{corollary}

Already, we can see that the above check can be done efficiently. As you may expect, removing the operations on the lowest value following this check results in a history that preserves admittance.

\begin{lemma}
    Let $H$ be a priority queue history with distinct values. Let the lowest priority value be $v = \min\set{\valOf{o} \;|\; o\in H}$. If there exists legal linearization on $H_v$, $l$, such that for all other values $v' > v$ and $o \in H_v \setminus \set{o_{\minsert(v)}}$, one of the following holds:
    \begin{enumerate}
        \item for all $o' \in H_{v'}$, $\invTimeOf{o'} < l(o)$, or
        \item for all $o' \in H_{v'}$, $l(o) < \resTimeOf{o'}$
    \end{enumerate}
    Then $H$ is linearizable iff $H \setminus H_v$ is linearizable.
\end{lemma}
\begin{proof}
    \begin{itemize}
        \item[($\Rightarrow$)] See Proposition \ref{reduce-one-value}.
        \item[($\Leftarrow$)] Let $H_v \setminus \set{o_{\minsert(v)}} = \set{o_1, o_2, ..., o_m}$, $t_i = l(o_i)$ and $G_i$ denote the union of the set $\set{H_{v_{i1}}, H_{v_{i2}}, ..., \allowbreak H_{v_{ik_i}}}$ for which $\invTimeOf{o'} < t_i$ for all $o' \in H_{v_{ij}}$, $1 \leq i \leq m$, $1 \leq j \leq k_i$. Without loss of generality, assume $t_i < t_{i+1}$ for all $1 \leq i < m$. It is clear that for each $1 \leq i \leq m$, $G_i'' = G_i' \setminus \bigcup_{1\leq j < i}{G_j'}$ is also well-matched, and since $G_i'' \subseteq H \setminus H_v$, it is also linearizable by Corollary \ref{reduce-well-matched}. Notice that for all $o'\in G_i''$, $t_{i-1} < \resTimeOf{o'}$ and $\invTimeOf{o'} < t_i$. Hence, there exists a legal linearization $l_i$ of $G_i''$ such that $t_{i-1} < l_i(o') < t_i$ by Lemma \ref{tight-hist} (assume $t_0$ to be 0).

Similarly, there must also exist a legal linearization $l_{m+1}$ of $G_{m+1}'' = H \setminus \bigcup_{1\leq j \leq m}{G_j'}$ such that $t_m < l_{m+1}(o)$ for all $o \in G_{m+1}''$. Let $l_v$ be a linearization of $H_v$ where $l_v(o_i) = t_i$. Reader may verify that the union of the linearizations $l_v, l_1, l_2, ..., l_{m+1}$ is indeed a legal linearization of $H$ by Proposition \ref{stack-partial-def} (note that we can always safely linearize $o_{\minsert(v)}$ to be before other operations in $H_v$).
    \end{itemize}
\end{proof}

\begin{corollary}\label{pqueue-reduce}
    Let $H$ be a priority queue history with distinct values. $H$ is linearizable iff for all $v \in \vals_H$, there exists a legal linearization on $H_v$, $l$, such that for all other values $v' > v$ and $o \in H_v \setminus \set{o_{\minsert(v)}}$, one of the following holds:
    \begin{enumerate}
        \item for all $o' \in H_{v'}$, $\invTimeOf{o'} < l(o)$, or
        \item for all $o' \in H_{v'}$, $l(o) < \resTimeOf{o'}$
    \end{enumerate}
\end{corollary}

Notice that Corollary \ref{pqueue-reduce} is really powerful in the context of a priority queue, where all values are totally ordered. We do not need to iteratively remove the lowest priority value to continuously solve the smaller sub-problem. We can, instead, perform the check on every value simultaneously without the need to iterate into a smaller problem. This allows us to derive a much simpler procedure to monitoring the linearizability of a priority queue history compared to stack.

\input{algos/pq-lin}

\begin{theorem}
    MLPQ is solvable in $O(n \log{n})$ time.
\end{theorem}
\begin{proof}

In \algoref{pq-algo}, $CritVal$ keeps a record of values that has an operation that has already responded and an operation that has not been invoked. Following Corollary \ref{pqueue-reduce}, the operation on a value $v$ can be greedily scheduled when $CritVal$ does not contain values of higher priority (i.e. $v \geq MaxValue$). $RunningOp$ is a map containing all ongoing operations categorized by its value. 

The sorting of events require $O(n\log{n})$ time, where $n$ is the number of operations in the given priority queue history $H$. In each iteration of events, we first update $CritVal$ and $RunningOp$ with a constant number of accesses to these two tree data structures, each giving $O(\log{n})$ time. Thereafter, we schedule any operations with no higher priority values in $CritVal$, with $O(m)$ accesses to $RunningOp$ and $CritVal$, where $m$ is the number of operations successfully scheduled. This gives us $O(m\log{n})$ time per iteration. Hence, the amortized time complexity of the entire algorithm is $O(n \log{n})$.
\end{proof}