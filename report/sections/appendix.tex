%!TEX root=../main.tex

\appendix

\section{Fast Stack Algorithm}\label{stack-fast}

In \algoref{stack-algo}, we observe that bottom values are acquired by complete removal of its operations on intervals where $CritVal$ contains no other values. Intuitively, we can discretize time intervals between each invocation and response event, resulting in $2n - 1$ time intervals in which we can schedule operations. We denote, in increasing order, these time intervals as $I_i$, for some $1 \leq i \leq 2n-1$. 

Intuitively, we just need an efficient procedure to determine all intervals where $|CritVal|\leq 1$, and greedily remove schedulable operations, and an efficient procedure to update the size of $CritVal$ within these intervals.

\begin{definition}[$\perm{I_i, v}{H}$]\label{stack-perm}
    Given stack history $H$, some interval $I_i = (t_i, t_{i+1})$, and value $v\in\vals_H$, $\perm{I_i, v}{H}$ holds when for all $v'\in\vals_H\setminus\set{v}$, either $\max\set{\invTimeOf{o}\;|\;o\in H_{v'}} \leq t_i$ or $t_{i+1}\leq \min\set{\resTimeOf{o}\;|\;o\in H_{v'}}$.
\end{definition}

Definition \ref{stack-perm} states that $\perm{I_i, v}{H}$ holds when $CritVal$ contains no values other than $v$ in $I_i$.

\begin{definition}[$\perm{I_i}{H}$]\label{stack-superperm}
    Given stack history $H$, and some interval $I_i = (t_i, t_{i+1})$, $\perm{I_i}{H}$ holds when for all $v\in\vals_H$, $\perm{I_i, v}{H}$ holds.
\end{definition}

Definition \ref{stack-superperm} states that $\perm{I_i}{H}$ holds when $CritVal$ is empty in $I_i$.

Let a \emph{specialized segment tree} be a special data structure that is initialized with an underlying history $H$, supporting two methods:
\begin{enumerate}
    \item $\getperm()$ returns:
    \begin{enumerate}
        \item a pair $\tuple{i, \varepsilon}$, if exists, such that $\perm{I_i}{H}$ holds, or
        \item a pair $\tuple{i, v}$, if exists, such that $\perm{I_i, v}{H}$ holds, or
        \item $\tuple{0, \varepsilon}$ if no such tuple exists.
    \end{enumerate}
    No tuple can be returned twice.
    \item $\rmsub(v)$ takes in value $v$ and updates the underlying history $H$ to $H\setminus H_v$.
\end{enumerate}

Now, instead of using a hashtable for $OpByVal$, we use interval trees to keep track of operations, enabling an efficient way to retrieve operations ongoing on the interval returned by the specialized segment tree.

\begin{algorithm}[t]
\caption{Faster Linearizability Monitoring for Stack Histories}
\algolabel{stack-algo-fast}
\myproc{\StackLin{$H$}}{
\tcp{Let $Op$ be an interval tree of operations, and $OpByVal$ be a hashmap of values to an interval tree of operations}
\For{$o\in H$}
{
    $Op$.insert($o$)\;
    $OpByVal[\valOf{o}]$.insert($o$)\;
}
\;
\tcp{SST is a specialized segment tree}
$SST$.init($H$)\;
\;
\While{\NOT $Op$.empty()}
{
    $i, v \gets SST.\getperm()$\;
    \If{$i = 0$}
    {
        \Return false
    }
    \;
    \If{$v = \varepsilon$}
    {
        \For{$o\in Op.\getoverlap(i)$}
        {
            $Op$.remove($o$)\;
            $OpByVal[\valOf{o}]$.remove($o$)\;
            \If{$OpByVal[\valOf{o}]$.empty()}
            {
                $SST.\rmsub(\valOf{o})$\;
            }
        }
    }
    \Else
    {
        \For{$o\in OpByVal[\valOf{o}].\getoverlap(i)$}
        {
            $Op$.remove($o$)\;
            $OpByVal[\valOf{o}]$.remove($o$)\;
            \If{$OpByVal[\valOf{o}]$.empty()}
            {
                $SST.\rmsub(\valOf{o})$\;
            }
        }
    }
}
\;
\Return true
}
\end{algorithm}

\algoref{stack-algo-fast} describes the optimized algorithm. Here, we assert that the initialization of $SST$ takes $O(n \log{n})$ time, $\getperm$ takes $O(\log{n})$ time each, $\getoverlap$ takes $O(m \log{n})$ time each, where $m$ is the number of operations returned, $\rmsub$ takes $O(\log{n})$ time each, and the insertion/removal of operations from the interval tree takes $O(\log{n})$ time each. As a result, the overall algorithm takes an amortized $O(n \log{n})$ time. The correctness follows directly from that of \algoref{stack-algo}.

Such a specialized segment tree does exist. $SST$ is intuitively a wrapper of two segment trees, say $S_1$ and $S_2$. Let $CI_v$ be the interval $[\min\set{\resTimeOf{o}\;|\;o\in H_{v'}}, \max\set{\invTimeOf{o}\;|\;o\in H_{v'}}]$. The methods of $SST$ can be implemented as such:

\begin{algorithm}
\caption{$SST$ Implementation}
\myproc{$\init(H)$}{
\For{$v \in \vals_H$}
{
    $S_1$.updateRange($CI_v$, $1$)\;
    $S_2$.updateRange($CI_v$, $v$) \tcp{Assume $\vals_H\subseteq \nats$}
}
}
\;
\myproc{$\getperm()$}{
\For{$v \in \vals_H$}
{
    $val, pos \gets S_1$.queryMin()\;
    $S_2$.updateRange($CI_v$, $v$)\;
    \If {$val = 0$}
    {
        $S_1$.updatePoint($pos$, $\infty$)\;
        return $\tuple{pos, \varepsilon}$ \tcp{$\perm{I_{pos}}{H}$ holds}
    }
    \ElseIf {$val = 1$}
    {
        $S_1$.updatePoint($pos$, $\infty$)\;
        $v \gets S_2$.query($pos$)\;
        \tcp{Cache $pos$ to be returned again after $\rmsub(v)$}
        return $\tuple{pos, v}$ \tcp{$\perm{I_{pos}, v}{H}$ holds}
    }
    \Else
    {
        return $\tuple{0, \varepsilon}$\;
    }
}
}
\;
\myproc{$\rmsub(v)$}{
    $S_1$.updateRange($CI_v$, $-1$)\;
    $S_2$.updateRange($CI_v$, $-v$)\;
}
\end{algorithm}