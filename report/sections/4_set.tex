%!TEX root=../main.tex

\section{Linearizability for the Set Data structure}
\seclabel{set}

In this section, we outline the linear time algorithm for monitoring linearizability for the simplest data type, namely set.

We define the signature of set operations to be the following:
\begin{enumerate*}
    \item $\minsert(x) \Rightarrow b$ that inserts value $x$ into the set and returns $\true$ if the insertion is successful, and $\false$ otherwise (value already in the set)
    \item $\remove(x) \Rightarrow b$ that removes value $x$ from the set and returns $\true$ if the removal is successful, and $\false$ otherwise (value absent in the set)
    \item $\contains(x) \Rightarrow b$ that returns $\true$ if $x$ is in the set, and $\false$ otherwise
\end{enumerate*}. 

\begin{problem*}[Monitoring Linearizability for Set (MLSet)]
   Given a set well-matched history $H$ with distinct values, is $H$ linearizable?
\end{problem*}

Recall that in any given histories, we have each value successfully inserted into the set to be distinct (specifically, $\minsert$ operations $o_\minsert$ where $\returnOf{o_\minsert} =\true$). We simplify our histories further to make our presentation simpler, as follows.
An $\minsert$ operation that returns $\false$, is semantically equivalent to a $\contains$ operation (of the same value) that returns $\true$. Similarly, a $\remove$ operation returning $\false$ is equivalent to $\contains$ operation returning $\false$.
Towards, this, in the following, we will also assume that the input history $H$ does not contain
any $\minsert$ or $\remove$ operations that return $\false$.

Thus, the only four kinds of operations in our histories are $\minsert$ and $\remove$ operations that return $\true$, and $\contains$ operations that can return either $\true$ or $\false$.

Let us now present the key insights behind our linear time algorithm for monitoring linearizability of set histories.
The first easy observation is that set histories can be monitored by focusing on the monitoring problem for each value, independent of other values:

\begin{proposition}[Locality on values]\label{set-locality}
    $H$ is linearizable iff $H_v$ is linearizable for all $v \in \vals_H$.
\end{proposition}

Secondly, it suffices to check, for every value, if the (unique) $\minsert$ operation and the (unique) $\remove$ operation on a given value $v$ can be scheduled so as to accommodate all other $\contains$ operations that returns $\true$ within the time interval induced by these chosen linearization points.

\begin{lemma}\label{set-iff}
    Given set history $H$, we define $H_v|_\true = \set{o\in H_v\;|\; \returnOf{o} = \true}$. We have $MinRes = \min\set{\resTimeOf{o}\;|\; \returnOf{o} = \true}$, and $MaxInv = \max\set{\invTimeOf{o}\;|\; \returnOf{o} = \true}$. $H_v$ is linearizable iff the corresponding conditions on each operation $o\in H_v$ holds:
    \begin{enumerate}
        \item if $\methodOf{o} = \minsert$, $\invTimeOf{o} < MinRes$,
        \item if $\methodOf{o} = \remove$, $\resTimeOf{o} > MaxInv$,
        \item\label{set-false-op} if $\returnOf{o} = \false$, either $\resTimeOf{o} > MaxInv$, or $\invTimeOf{o} < MinRes$
    \end{enumerate}
\end{lemma}
\begin{proof}
\begin{itemize}
    \item[($\Rightarrow$)]
    Assume legal linearization $l$ of $H_v$. It is clear that for all $o\in H_v|_\true$, $l(o_\minsert) \leq l(o) \leq l(o_\remove)$. Hence, $\invTimeOf{o_\minsert} < MinRes$. Otherwise, there must exist an operation $o' \in H_v|_\true$ such that $l(o') < \resTimeOf{o'} \leq \invTimeOf{o_\minsert} < l(o_\minsert)$, contradiction. Similarly, $\resTimeOf{o_\remove} > MaxInv$.

    On the other hand, for all $o\in H_v \setminus H_v|_\true$, we must have that either $l(o) < l(o_\minsert)$ or $l(o_\remove) < l(o)$. Hence, either $\invTimeOf{o} < l(o) < l(o_\minsert) < MinRes$ or $\resTimeOf{o} > l(o) > l(o_\remove) > MaxInv$.
    
    \item[($\Leftarrow$)]
    Suppose that the given conditions hold, we construct a legal linearization $l$. Assume $MinRes < MaxInv$. We safely schedule operations that return $\false$ either before $MinRes$ or after $MaxInv$, and we can do that by property \ref{set-false-op}. Thereafter, we schedule all operations returning $\true$ within the interval $(MinRes - \epsilon, MaxInv + \epsilon)$ for some sufficiently small rational $\epsilon$, such that for all operations $o' \in H_v \setminus H_v|_\true$, $l(o') \notin (MinRes - \epsilon, MaxInv + \epsilon)$.
    
    Now assume $MinRes \geq MaxInv$, we then safely schedule operations that return $\false$ either before or after $MinRes$. Again, all operations that return $\true$ is concurrent and consecutively schedulable within $(MinRes - \epsilon, MinRes + \epsilon)$ for some sufficiently small $\epsilon$, such that for all operations $o' \in H_v \setminus H_v|_\true$, $l(o') \notin (MinRes - \epsilon, MinRes + \epsilon)$.
\end{itemize}
\end{proof}

The above two characterizations, Proposition \ref{set-locality} and Lemma \ref{set-iff}, lend themselves to our optimal algorithm, shown in \algoref{set-algo}.

\input{algos/set-lin}

\begin{theorem}
    MLSet is solvable in linear time.
\end{theorem}

\begin{proof}
The given algorithm checks exactly if the given set history satisfies the conditions listed in Lemma \ref{set-iff}, and performs the check for different values simultaneously in just two iterations of the given history. Hence, the correctness of the algorithm follows directly from Proposition \ref{set-locality} and Lemma \ref{set-iff}. \algoref{set-algo} runs in $O(n)$ time. The conclusion follows.
\end{proof}