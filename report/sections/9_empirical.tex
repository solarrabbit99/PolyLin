%!TEX root=../main.tex

\section{Empirical Results}

\begin{figure}
\begin{tikzpicture}
  \begin{axis}[
      legend style={font=\small},
      legend pos=north west,
      ylabel=runtime (s),
      xlabel=no. of operations,
      cycle list={
        {blue,mark=triangle*},
        {red,mark=triangle*},
        {orange,mark=triangle*}
      }
  ]
  \addplot+[only marks]
  table[x=num_oper, y=runtime]
  {experiments/ms-oper.dat};
  \addplot+[only marks]
  table[x=num_oper, y=runtime]
  {experiments/treiber-oper.dat};
  \addplot+[only marks]
  table[x=num_oper, y=runtime]
  {experiments/pqueue-oper.dat};
  \legend{ms queue,treiber stack,priority queue}
  \end{axis}
\end{tikzpicture}
\caption{All algorithms run in $O(n \log{n})$ in practice}
\label{graph-oper}
\end{figure}

In this section, we show that our proposed algorithms outperform all existing known tools and linearizability monitors in 2 ways:

\begin{enumerate}
    \item \textbf{time complexity}: our algorithms are polynomial time, while existing tools that are theoretically sound and complete are exponential in the worst case.
    \item \textbf{theoretical soundness}: our algorithms are sound and complete, while existing tools that monitor linearizability in polynomial time lacks theoretical guarantees.
\end{enumerate}

We achieve the above by specializing our algorithms to each cater for specific data types. While existing tools are general and account for arbitrary data types or group of data types, we argue that the algorithms we propose covers the data types that are commonly used in practical concurrent settings.

The experiments were conducted on Scal's implementation of Michael Scott queue and Treiber stack. For data types that are missing in Scal's repository, we used simple lock-based implementations to generate histories with guaranteed linearizability. Histories of 100,000 to 1,000,000 operations are generated via a routine of 50 consumers and 50 producers, and time taken for our algorithms to verifying their linearizability is recorded in presented in Figure \ref{graph-oper}.

\begin{figure}
\begin{tikzpicture}
  \begin{axis}[
      boxplot,
      legend style={font=\small},
      legend pos=north west,
      ylabel=runtime (s),
      xlabel=no. of producers/consumers,
      cycle list={
        {blue,mark=triangle*},
        {red,mark=triangle*},
        {orange,mark=triangle*}
      }
  ]
  \addplot+[only marks]
  table[x=num_prod, y=runtime]
  {experiments/ms-proc.dat};
  \addplot+[only marks]
  table[x=num_prod, y=runtime]
  {experiments/treiber-proc.dat};
  \addplot+[only marks]
  table[x=num_prod, y=runtime]
  {experiments/pqueue-proc.dat};
  \legend{ms queue,treiber stack,priority queue}
  \end{axis}
\end{tikzpicture}
\caption{Number of threads has limited effect on runtime}
\label{graph-proc}
\end{figure}